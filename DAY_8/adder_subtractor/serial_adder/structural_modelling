module d_ff (
    input clk, clear, d,
    output reg q
);
    always @(posedge clk or posedge clear)
        if (clear) q <= 0;
        else q <= d;
endmodule

module shift_register (
    input clk, shift_control,
    input serial_in,
    output reg [7:0] data,
    output serial_out
);
    assign serial_out = data[0];

    always @(posedge clk) begin
        if (shift_control)
            data <= {serial_in, data[7:1]};
    end
endmodule

module full_adder_df (
    input x, y, cin,
    output s, cout
);
    assign s = x ^ y ^ cin;
    assign cout = (x & y) | (cin & (x ^ y));
endmodule

module serial_adder (
    input clk,
    input reset,
    input shift_control,
    input serial_in,
    output sum_out
);
    wire [7:0] A_out, B_out;
    wire a_bit, b_bit;
    wire s, cout;
    wire cin;

    shift_register regA (.clk(clk), .shift_control(shift_control), .serial_in(serial_in), .data(A_out), .serial_out(a_bit));
    shift_register regB (.clk(clk), .shift_control(shift_control), .serial_in(serial_in), .data(B_out), .serial_out(b_bit));
    full_adder_df fa (.x(a_bit), .y(b_bit), .cin(cin), .s(s), .cout(cout));
    d_ff dff (.clk(clk), .clear(reset), .d(cout), .q(cin));

    assign sum_out = s;
endmodule
